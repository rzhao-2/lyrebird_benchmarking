
import extern
import os
import sys
sys.path.append("..")
# from app import object

from tool_reference_data import *

ruleorder: prepare_phanta_inputs > phanta_profile

num_threads = config['benchmarking_threads']
kraken_num_threads = 999 # never let kraken be parallelised, because otherwise it will exhaust the RAM.

output_prefix = 'output_'
output_dirs = list([output_prefix+tool for tool in tools])
output_dirs_dict = dict(zip(tools, output_dirs))
tempdir = '/tmp'

benchmark_dir = 'benchmarks'

datasets = list(['marine'+str(i) for i in range(10)])

fastq_dir = 'local_reads'
truth_dir = os.path.join(workflow.basedir, 'truths')
genome_fasta_paths = 'genome_rep_paths.csv'
coverage_definitions_folder = 'coverage_definitions'

# Restrict to r207-consistent tools
# tools = r207_tools

# debug
tools = ['lyrebird']
# datasets = [datasets[6]] # debug

##################################################################### things that should be in config

viral_metadata = '../viral_metadata_reconstructed.tsv'
# mpa_db = "/mnt/weka/scratch/microbiome/n10927662/mpa/db"
mpa_db = "/mnt/hpccs01/home/n10927662/db/mpa"

##################################################################### reference databases

lyrebird_metapackage = "/mnt/hpccs01/work/microbiome/msingle/rossenzhao/phrogs_v4.1/0.3/metapackage/lyrebird_v0.3.1_phrog_v4.1_20250720.smpkg"
# lyrebird_metapackage_local = join(output_dirs_dict['lyrebird'], 'data', os.path.basename(lyrebird_metapackage))

#####################################################################


rule all:
    input:
        expand(output_prefix+"{tool}/opal/{sample}.opal_report", sample=datasets, tool=tools),
        # expand(output_dirs_dict['phanta'] + "/{sample}_output", sample=datasets),
        expand(output_dirs_dict['phanta'] + "/{sample}.output.done", sample=datasets),
        expand(output_dirs_dict['metaphlan4'] + "/{sample}.profile", sample=datasets)


rule generate_community_and_reads:
    output:
        r1=fastq_dir + "/{sample}.1.fq.gz",
        r2=fastq_dir + "/{sample}.2.fq.gz",
        condensed = truth_dir + "/{sample}.condensed",
        genomewise = truth_dir + "/{sample}.genomewise.csv",
        done = touch(truth_dir + "/{sample}.finished"),
        done2 = touch(fastq_dir + "/{sample}.finished"),
    params:
        coverage_number = lambda wildcards: wildcards.sample.replace('marine', ''),
    threads: num_threads
    conda:
        'envs/art.yml'
    shell:
        "{workflow.basedir}/generate_community.py --art art_illumina --threads {threads} --coverage-file {workflow.basedir}/coverage_definitions/coverage{params.coverage_number}.tsv --viral-metadata {viral_metadata} --genome-list {genome_fasta_paths} --output-condensed {output.condensed} -1 {fastq_dir}/{wildcards.sample}.1.fq.gz -2 {fastq_dir}/{wildcards.sample}.2.fq.gz --output-genomewise-coverage {output.genomewise}"

rule truth_condensed_to_biobox:
    input:
        condensed = truth_dir + "/{sample}.condensed",
    output:
        biobox = truth_dir + "/{sample}.condensed.biobox",
    conda:
        "envs/singlem.yml"
    shell:
        "{workflow.basedir}/../bin/condensed_profile_to_biobox.py --input-condensed-table {input.condensed} " \
        "--output-biobox {output.biobox}"

# def get_condensed_to_biobox_extra_args(tool):
#     if tool in tools_with_filled_output_profiles:
#         return ' --no-fill'
#     else:
#         return ''

rule tool_condensed_to_biobox:
    input:
        profile = output_prefix + "{tool}/{tool}/{sample}.profile",
        truth = truth_dir + "/{sample}.condensed.biobox",
    # params:
        # extra_args = lambda wildcards: get_condensed_to_biobox_extra_args(wildcards.tool)
    output:
        biobox = output_prefix + "{tool}/biobox/{sample}.biobox",
    conda:
        "envs/singlem.yml"
    shell:
        # "{workflow.basedir}/../bin/condensed_profile_to_biobox.py {params.extra_args} --input-condensed-table {input.profile} " \
        "{workflow.basedir}/../bin/condensed_profile_to_biobox.py --input-condensed-table {input.profile} " \
        "--output-biobox {output.biobox} --template-biobox {input.truth} "

rule opal:
    input:
        biobox = output_prefix+"{tool}/biobox/{sample}.biobox",
        truth = truth_dir + "/{sample}.condensed.biobox",
    params:
        output_dir = output_prefix+"{tool}",
        output_opal_dir = output_prefix+"{tool}/opal/{sample}.opal_output_directory",
    output:
        report=output_prefix+"{tool}/opal/{sample}.opal_report",
        done=output_prefix+"{tool}/opal/{sample}.opal_report.done",
    conda:
        'envs/opal.yml'
    shell:
        "opal.py -g {input.truth} -o {params.output_opal_dir} {input.biobox} || echo 'expected opal non-zero existatus'; mv {params.output_opal_dir}/results.tsv {output.report} && rm -rf {params.output_opal_dir} && touch {output.done}"


###############################################################################################
###############################################################################################
###############################################################################################
#########
######### tool-specific rules - lyrebird first

# rule lyrebird_copy_metapackage:
#     input:
#         lyrebird_metapackage
#     output:
#         db=directory(lyrebird_metapackage_local),
#         done=output_dirs_dict['lyrebird'] + "/lyrebird/data/done",
#     shell:
#         "cp -rL {input} {output.db} && touch {output.done}"

rule lyrebird_run_to_profile:
    input:
        r1=fastq_dir + "/{sample}.1.fq.gz",
        r2=fastq_dir + "/{sample}.2.fq.gz",
        # db=lyrebird_metapackage_local,
        db=lyrebird_metapackage,
        # data_done=output_dirs_dict['lyrebird'] + "/lyrebird/data/done"
    benchmark:
        benchmark_dir + "/lyrebird/{sample}-"+str(num_threads)+"threads.benchmark"
    output:
        report=output_dirs_dict['lyrebird'] + "/lyrebird/{sample}.profile",
        otu_table = output_dirs_dict['lyrebird'] + "/lyrebird/{sample}.otu_table",
        done=touch(output_dirs_dict['lyrebird'] + "/lyrebird/{sample}.profile.done")
    conda:
        "singlem-v0.19.0"
    threads:
        num_threads
    resources:
        mem_mb = 16 * 1024,
        runtime = 1 * 60,
    log:
        output_dirs_dict['lyrebird'] + "/logs/lyrebird/{sample}.log"
    shell:
        "lyrebird pipe --threads {threads} -1 {input.r1} -2 {input.r2} -p {output.report} --otu-table {output.otu_table} --metapackage {input.db} &> {log}"

### metaphlan4
rule metaphlan4_profile_vsc:
    input:
        r1=fastq_dir + "/{sample}.1.fq.gz",
        r2=fastq_dir + "/{sample}.2.fq.gz"
    benchmark:
        benchmark_dir + "/metaphlan4/{sample}-"+str(num_threads)+"threads.benchmark"
    params:
        bowtie2db = mpa_db, # database is now ~20GB, so this should be installed outside of the conda environment
    output:
        bowtie2out = temp(output_dirs_dict['metaphlan4'] + "/{sample}.b2o"),
        sam = temp(output_dirs_dict['metaphlan4'] + "/{sample}.sam"),
        report=output_dirs_dict['metaphlan4'] + "/{sample}.profile",
        done=touch(output_dirs_dict['metaphlan4'] + "/{sample}.output.done")
    conda:
        # "envs/metaphlan.yml"
        "metaphlan-v4.2.2"
    threads:
        num_threads
    resources:
        mem_mb = 40 * 1024,
        runtime = 1 * 60,
    log:
        output_dirs_dict['metaphlan4'] + "/logs/{sample}.log"
    shell:
        "rm -f {output.bowtie2out}; " \
        "metaphlan {input.r1},{input.r2} " \
        "--db_dir {params.bowtie2db} --mapout {output.bowtie2out} --nproc {threads} " \
        "--input_type fastq --profile_vsc --vsc_out {output.report} -s {output.sam} &> {log}; touch {output.report}" # touch output file because it will not create the file if not detected

### phanta
rule prepare_phanta_inputs:
    input:
        r1=fastq_dir + "/{sample}.1.fq.gz",
        r2=fastq_dir + "/{sample}.2.fq.gz"
    params:
        phanta_config_example = "phanta_config_example.yaml",
        # outdir = tempdir + "/{sample}_output_phanta",
        outdir = output_dirs_dict['phanta'] + "/{sample}_output_phanta",
        threads = num_threads
    output:
        sample_file = temp(output_dirs_dict['phanta'] + "/{sample}.txt"),
        phanta_config = temp(output_dirs_dict['phanta'] + "/{sample}_config.yaml"),
        # done=touch(output_dirs_dict['phanta'] + "/{sample}_config.done")
    log:
        output_dirs_dict['phanta'] + "/logs/{sample}_prepare.log"
    script:
        "prepare_phanta_inputs.py"

rule phanta_profile:
    input:
        sample_file = output_dirs_dict['phanta'] + "/{sample}.txt",
        phanta_config = output_dirs_dict['phanta'] + "/{sample}_config.yaml"
    params:
        outdir = directory(output_dirs_dict['phanta'] + "/{sample}_output"),
    #     outdir = tempdir + "/{sample}_output_phanta"
    benchmark:
        benchmark_dir + "/phanta/{sample}-"+str(num_threads)+"threads.benchmark"
    output:
        # outdir = directory(output_dirs_dict['phanta'] + "/{sample}_output"),
        done=touch(output_dirs_dict['phanta'] + "/{sample}.output.done")
    conda:
        "phanta_env"
    threads:
        num_threads
    resources:
        mem_mb = 36 * 1024,
        runtime = 1 * 60,
    log:
        output_dirs_dict['phanta'] + "/logs/{sample}.log"
    shell:
        "rm -rf {params.outdir}; snakemake -s /mnt/hpccs01/home/n10927662/phanta/Snakefile --cores {threads} --max-threads {threads} --configfile {input.phanta_config} --use-conda --jobs 99 -F"
        # "rm -rf {output.outdir}; snakemake -s /mnt/hpccs01/home/n10927662/phanta/Snakefile --cores {threads} --max-threads {threads} --configfile {input.phanta_config} --nolock --use-conda --jobs 99 -F"

# rule move_phanta_profile:
#     input:
#         done = output_dirs_dict['phanta'] + "/{sample}.output.done"
#     params:
#         input_folder = directory(tempdir + "/{sample}_output_phanta"),
#     output:
#         output_folder = directory(output_dirs_dict['phanta'] + "/{sample}_output"),
#         done=touch(output_dirs_dict['phanta'] + "/{sample}.done")
#     shell:
#         "mv {params.input_folder} {output.output_folder}"